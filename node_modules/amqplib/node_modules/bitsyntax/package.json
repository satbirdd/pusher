{
  "author": {
    "name": "Michael Bridgen",
    "email": "<mikeb@squaremobius.net"
  },
  "name": "bitsyntax",
  "description": "Pattern-matching on byte buffers",
  "version": "0.0.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/squaremo/bitsyntax-js.git"
  },
  "main": "./index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": ">=0.6"
  },
  "dependencies": {
    "pegjs": "~0.7",
    "buffer-more-ints": ""
  },
  "devDependencies": {},
  "readme": "# Byte-wise matching for Node.JS\n\nGives a compact syntax for parsing and constructing byte buffers,\nderived from [Erlang's bit\nsyntax](http://www.erlang.org/doc/programming_examples/bit_syntax.html#id64858).\n\n    var bitsyntax = require('bitsyntax');\n    var pattern = bitsyntax.compile('len:8/integer, string:len/binary');\n    var bound = pattern(new Buffer([4, 0x41, 0x42, 0x43, 0x44]));\n    bound.string\n    // => <Buffer 41 42 43 44>\n\nA typical use of this is parsing byte streams from sockets. For\nexample, size-prefixed frames:\n\n    var framePattern = bitsyntax.compile('len:32/integer, frame:len/binary, rest/binary');\n    socket.on('data', function process(data) {\n      var m;\n      if (m = framePattern(data)) {\n        emit('frame', m.frame);\n        process(m.rest);\n      }\n      else {\n        stashForNextData(data);\n      }\n    });\n\nPatterns can also be used to construct binaries from supplied values:\n\n   var spdyDataFrame = require('bitsyntax')\n     .constructor('streamId:32, flags:8, length:24, data/binary');\n\n   spdyDataFrame({streamId:5, flags:0, length:bin.length, data:bin});\n\nOne or more segments of a pattern may also be supplied in multiple\narguments, if that is more convenient; this makes it easier to split a\nlong pattern over lines:\n\n    var p = bitsyntax.compile('size:8, payload:size/binary',\n                              'rest/binary');\n\n## API\n\n### `compile`\n\nCompiles a pattern to a function that will return either a map of\nbindings, or `false`, given a buffer and optionally an\nenvironment. The environment contains values for the bound variables\nin the pattern (if there are any).\n\n    var p = bitsyntax.compile('header:headerSize/binary, rest/binary');\n    var b = p(new Buffer([1, 2, 3, 4, 5]), {headerSize: 3});\n    b.header\n    // => <Buffer 01 02 03>\n\n### `parse` and `match`\n\nIn combination, equivalent to `compile`; may be useful if you want to\nexamine the internal structure of patterns.\n\n`parse` takes strings as for `compile`, and returns the internal\nrepresentation of the pattern. `match` takes this representation, a\nbuffer, and optionally an environment, and returns the bindings or\nfalse (as with `compile`).\n\n    var p = bitsyntax.parse('header:headerSize/binary',\n                            'rest/binary');\n    var b = bitsyntax.match(p, new Buffer([1, 2, 3, 4, 5]),\n                              {headerSize: 3});\n    b.header\n    // => <Buffer 01 02 03>\n\n### `constructor`\n\nTakes a pattern and returns a function that will construct a byte\nbuffer, given values for the variables mentioned in the pattern.\n\n    var cons = bitsyntax.constructor('size:8, bin/binary');\n    cons({size:6, bin:newBuffer('foobar')});\n    // => <Buffer 06 66 6f 6f 62 61 72>\n\nPatterns supplied to constructors are slightly different to patterns\nsupplied for matching, as noted below.\n\n## Patterns\n\nPatterns are sequences of segments, each matching a value. Segments\nhave the general form\n\n     value:size/type_specifier_list\n\nThe size and type specifier list may be omitted, giving three extra\nvariations:\n\n    value\n    value:size\n    value/type_specifier_list\n\nThe type specifier list is a list of keywords separated by\nhyphens. Type specifiers are described below.\n\nPatterns are generally supplied as strings, with a comma-separated\nseries of segments.\n\n### Variable or value\n\nThe first part of a segment gives a variable name or a literal\nvalue. If a variable name is given, the value matched by the segment\nwill be bound to that variable name for the rest of the pattern. If a\nliteral value is given, the matched value must equal that value.\n\nIn constructors, the literal value will be copied into the result\nbinary according to the type it is given. A variable name indicates a\nspace into which a value supplied to the constructor will be copied.\n\nThe special variable name `_` discards the value matched; i.e., it\nsimply skips over the appropriate number of bits in the input. '_' is\nnot allowed in constructors.\n\n### Size and unit\n\nThe size of a segment is given following the value or variable,\nseparated with a colon:\n\n    foo:32\n\nThe unit is given in the list of specifiers as `'unit' and\nan integer from 0..256, separated by a colon:\n\n    foo:4/integer-unit:8\n\nThe size is the number of units in the value; the unit is given as a\nnumber of bits. Unit can be of use, for example, when you want to\nmatch integers of a number of bytes rather than a number of bits.\n\nFor integers and floats, the default unit is 1 bit; to keep things\naligned on byte boundaries, `unit * size` must currently be a multiple\nof 8. For binaries the default unit is 8, and the unit must be a\nmultiple of 8.\n\nIf the size is omitted and the type is integer, the size defaults to\n8. If the size is omitted and the type is binary, the segment will\nmatch all remaining bytes in the input; such a segment may only be\nused at the end of a pattern.\n\nThe size may also be given as an integer variable matched earlier in\nthe pattern, as in the example given at the top.\n\nIn constructors, numbers will be rounded, masked or padded to fit the\nsize and units given; for example, `'256:8'` gives the binary\n`Buffer<00>` because the lowest eight bits are 0; `'255:16` gives the\nbinary `Buffer<00 ff>`.\n\n### Type name specifier\n\nOne of `integer`, `binary`, `string`, `float`. If not given, the\ndefault is `integer`.\n\nAn integer is a big- or little-endian, signed or unsigned\ninteger. Integers up to 32 bits are supported. Signed integers are\ntwo's complement format. In JavaScript, only integers between -(2^53)\nand 2^53 can be represented, and bitwise operators are only defined on\n32-bit signed integers.\n\nA binary is simply a byte buffer; usually this will result in a slice\nof the input buffer being returned, so beware mutation.\n\nA string is a UTF8 string consisting of the given number of bytes.\n\nA float is a 32- or 64-bit IEEE754 floating-point value (this is the\nstandard JavaScript uses, as do Java and Erlang).\n\n### Endianness specifier\n\nIntegers may be big- or little-endian; this refers to which 'end' of\nthe bytes making up the integer are most significant. In network\nprotocols integers are usually big-endian, meaning the first\n(left-most) byte is the most significant, but this is not always the\ncase.\n\nA specifier of `big` means the integer will be parsed (or written into\nthe result) as big-endian, and `little` means the integer will be\nparsed or written as little-endian. The default is big-endian.\n\n### Signedness specifier\n\nInteger segments may include a specifier of `signed` or `unsigned`. A\nsigned integer is parsed as two's complement format. The default is\nunsigned.\n\nSignedness is ignored in constructors.\n\n### Literal strings\n\nA quoted string appearing in a pattern is a shorthand for the bytes in\nits UTF8 encoding. For example,\n\n    \"foobar\", _/binary\n\nmatches any buffer that starts with the bytes `0x66, 0x6f, 0x6f, 0x62,\n0x61, 0x72`.\n\nWhen used in a constructor, a quoted string is copied verbatim into\nthe result.\n\n## Examples\n\nIn the following the matched bytes are given in array notation for\nconvenience. Bear in mind that `match()` actually takes a buffer for\nthe bytes to match against. The phrase \"returns X as Y\" or \"binds X as\nY\" means the return value is an object with value X mapped to the key\nY.\n\n    54\n\nMatches the single byte `54`.\n\n    54:32\n\nMatches the bytes [0,0,0,54].\n\n    54:32/little\n\nMatches the bytes [54,0,0,0].\n\n    54:4/unit:8\n\nMatches the bytes [0,0,0,54].\n\n    int:32/signed\n\nMatches a binary of four bytes, and returns a signed 32-bit integer as\n`int`.\n\n    len:16, str:len/binary\n\nMatches a binary of `2 + len` bytes, and returns an unsigned 16-bit\ninteger as `len` and a buffer of length `len` as `str`.\n\n    len:16, _:len/binary, rest/binary\n\nMatches a binary of at least `2 + len` bytes, binds an unsigned 16-bit\ninteger as `len`, ignores the next `len` bytes, and binds the\nremaining (possibly zero-length) binary as `rest`.\n",
  "readmeFilename": "README.md",
  "_id": "bitsyntax@0.0.2",
  "dist": {
    "shasum": "fa2ab0a5b950cd5aed90b6dbe6ba2a245d75e9e8"
  },
  "_from": "bitsyntax@0.0.2"
}
